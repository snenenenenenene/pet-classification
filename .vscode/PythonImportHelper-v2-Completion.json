[
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "pandas",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pandas",
        "description": "pandas",
        "detail": "pandas",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "matplotlib.pyplot",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib.pyplot",
        "description": "matplotlib.pyplot",
        "detail": "matplotlib.pyplot",
        "documentation": {}
    },
    {
        "label": "tensorflow",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tensorflow",
        "description": "tensorflow",
        "detail": "tensorflow",
        "documentation": {}
    },
    {
        "label": "keras",
        "importPath": "tensorflow",
        "description": "tensorflow",
        "isExtraImport": true,
        "detail": "tensorflow",
        "documentation": {}
    },
    {
        "label": "to_categorical",
        "importPath": "tensorflow.keras.utils",
        "description": "tensorflow.keras.utils",
        "isExtraImport": true,
        "detail": "tensorflow.keras.utils",
        "documentation": {}
    },
    {
        "label": "load_img",
        "importPath": "tensorflow.keras.preprocessing.image",
        "description": "tensorflow.keras.preprocessing.image",
        "isExtraImport": true,
        "detail": "tensorflow.keras.preprocessing.image",
        "documentation": {}
    },
    {
        "label": "img_to_array",
        "importPath": "tensorflow.keras.preprocessing.image",
        "description": "tensorflow.keras.preprocessing.image",
        "isExtraImport": true,
        "detail": "tensorflow.keras.preprocessing.image",
        "documentation": {}
    },
    {
        "label": "load_img",
        "importPath": "tensorflow.keras.preprocessing.image",
        "description": "tensorflow.keras.preprocessing.image",
        "isExtraImport": true,
        "detail": "tensorflow.keras.preprocessing.image",
        "documentation": {}
    },
    {
        "label": "img_to_array",
        "importPath": "tensorflow.keras.preprocessing.image",
        "description": "tensorflow.keras.preprocessing.image",
        "isExtraImport": true,
        "detail": "tensorflow.keras.preprocessing.image",
        "documentation": {}
    },
    {
        "label": "ImageDataGenerator",
        "importPath": "tensorflow.python.keras.preprocessing.image",
        "description": "tensorflow.python.keras.preprocessing.image",
        "isExtraImport": true,
        "detail": "tensorflow.python.keras.preprocessing.image",
        "documentation": {}
    },
    {
        "label": "classification_report",
        "importPath": "sklearn.metrics",
        "description": "sklearn.metrics",
        "isExtraImport": true,
        "detail": "sklearn.metrics",
        "documentation": {}
    },
    {
        "label": "log_loss",
        "importPath": "sklearn.metrics",
        "description": "sklearn.metrics",
        "isExtraImport": true,
        "detail": "sklearn.metrics",
        "documentation": {}
    },
    {
        "label": "accuracy_score",
        "importPath": "sklearn.metrics",
        "description": "sklearn.metrics",
        "isExtraImport": true,
        "detail": "sklearn.metrics",
        "documentation": {}
    },
    {
        "label": "train_test_split",
        "importPath": "sklearn.model_selection",
        "description": "sklearn.model_selection",
        "isExtraImport": true,
        "detail": "sklearn.model_selection",
        "documentation": {}
    },
    {
        "label": "tensorflowjs",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tensorflowjs",
        "description": "tensorflowjs",
        "detail": "tensorflowjs",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "mapper",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def mapper(value):\n    return reverse_mapping[value]\nprediction=model.predict(prediction_image)\nvalue=np.argmax(prediction)\nmove_name=mapper(value)\nprint(\"Prediction is {}.\".format(move_name))\nprint(test.shape)\nprediction2=model.predict(test)\nprint(prediction2.shape)\npred2=[]",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "TRAIN",
        "kind": 5,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "TRAIN = 'breeds/TRAIN'\nTEST = 'breeds/TEST'\ndataset=[] \nname=[]\ncount=0\npet_dict=[]\nfor file in os.listdir(TRAIN):\n    pet_dict+=[file]\n# mapping={ 'basset_hound':0, 'beagle':1, 'russian_blue':2, 'pomeranian':3, 'ragdoll':4, \n#          'staffordshire_bull_terrier':5, 'keeshond':6, 'siamese':7, 'pug':8, 'shiba_inu':9, ",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "TEST",
        "kind": 5,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "TEST = 'breeds/TEST'\ndataset=[] \nname=[]\ncount=0\npet_dict=[]\nfor file in os.listdir(TRAIN):\n    pet_dict+=[file]\n# mapping={ 'basset_hound':0, 'beagle':1, 'russian_blue':2, 'pomeranian':3, 'ragdoll':4, \n#          'staffordshire_bull_terrier':5, 'keeshond':6, 'siamese':7, 'pug':8, 'shiba_inu':9, \n#          'american_pit_bull_terrier':10, 'bengal':11, 'british_shorthair':12, 'newfoundland':13, ",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "datagen",
        "kind": 5,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "datagen = ImageDataGenerator(horizontal_flip=True,vertical_flip=True,rotation_range=20,zoom_range=0.2,\n                        width_shift_range=0.2,height_shift_range=0.2,shear_range=0.1,fill_mode=\"nearest\")\npretrained_model3 = tf.keras.applications.DenseNet121(input_shape=(180,180,3),include_top=False,weights='imagenet',pooling='avg')\npretrained_model3.trainable = False\ninputs3 = pretrained_model3.input\nx3 = tf.keras.layers.Dense(128, activation='relu')(pretrained_model3.output)\noutputs3 = tf.keras.layers.Dense(37, activation='softmax')(x3)\nmodel = tf.keras.Model(inputs=inputs3, outputs=outputs3)\nmodel.compile(optimizer='adam',loss='categorical_crossentropy',metrics=['accuracy'])\nhis=model.fit(datagen.flow(trainx,trainy,batch_size=32),validation_data=(testx,testy),epochs=30)",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "pretrained_model3",
        "kind": 5,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "pretrained_model3 = tf.keras.applications.DenseNet121(input_shape=(180,180,3),include_top=False,weights='imagenet',pooling='avg')\npretrained_model3.trainable = False\ninputs3 = pretrained_model3.input\nx3 = tf.keras.layers.Dense(128, activation='relu')(pretrained_model3.output)\noutputs3 = tf.keras.layers.Dense(37, activation='softmax')(x3)\nmodel = tf.keras.Model(inputs=inputs3, outputs=outputs3)\nmodel.compile(optimizer='adam',loss='categorical_crossentropy',metrics=['accuracy'])\nhis=model.fit(datagen.flow(trainx,trainy,batch_size=32),validation_data=(testx,testy),epochs=30)\ny_pred=model.predict(testx)\npred=np.argmax(y_pred,axis=1)",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "pretrained_model3.trainable",
        "kind": 5,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "pretrained_model3.trainable = False\ninputs3 = pretrained_model3.input\nx3 = tf.keras.layers.Dense(128, activation='relu')(pretrained_model3.output)\noutputs3 = tf.keras.layers.Dense(37, activation='softmax')(x3)\nmodel = tf.keras.Model(inputs=inputs3, outputs=outputs3)\nmodel.compile(optimizer='adam',loss='categorical_crossentropy',metrics=['accuracy'])\nhis=model.fit(datagen.flow(trainx,trainy,batch_size=32),validation_data=(testx,testy),epochs=30)\ny_pred=model.predict(testx)\npred=np.argmax(y_pred,axis=1)\nground = np.argmax(testy,axis=1)",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "inputs3",
        "kind": 5,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "inputs3 = pretrained_model3.input\nx3 = tf.keras.layers.Dense(128, activation='relu')(pretrained_model3.output)\noutputs3 = tf.keras.layers.Dense(37, activation='softmax')(x3)\nmodel = tf.keras.Model(inputs=inputs3, outputs=outputs3)\nmodel.compile(optimizer='adam',loss='categorical_crossentropy',metrics=['accuracy'])\nhis=model.fit(datagen.flow(trainx,trainy,batch_size=32),validation_data=(testx,testy),epochs=30)\ny_pred=model.predict(testx)\npred=np.argmax(y_pred,axis=1)\nground = np.argmax(testy,axis=1)\nprint(classification_report(ground,pred))",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "x3",
        "kind": 5,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "x3 = tf.keras.layers.Dense(128, activation='relu')(pretrained_model3.output)\noutputs3 = tf.keras.layers.Dense(37, activation='softmax')(x3)\nmodel = tf.keras.Model(inputs=inputs3, outputs=outputs3)\nmodel.compile(optimizer='adam',loss='categorical_crossentropy',metrics=['accuracy'])\nhis=model.fit(datagen.flow(trainx,trainy,batch_size=32),validation_data=(testx,testy),epochs=30)\ny_pred=model.predict(testx)\npred=np.argmax(y_pred,axis=1)\nground = np.argmax(testy,axis=1)\nprint(classification_report(ground,pred))\nget_acc = his.history['accuracy']",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "outputs3",
        "kind": 5,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "outputs3 = tf.keras.layers.Dense(37, activation='softmax')(x3)\nmodel = tf.keras.Model(inputs=inputs3, outputs=outputs3)\nmodel.compile(optimizer='adam',loss='categorical_crossentropy',metrics=['accuracy'])\nhis=model.fit(datagen.flow(trainx,trainy,batch_size=32),validation_data=(testx,testy),epochs=30)\ny_pred=model.predict(testx)\npred=np.argmax(y_pred,axis=1)\nground = np.argmax(testy,axis=1)\nprint(classification_report(ground,pred))\nget_acc = his.history['accuracy']\nvalue_acc = his.history['val_accuracy']",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "model",
        "kind": 5,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "model = tf.keras.Model(inputs=inputs3, outputs=outputs3)\nmodel.compile(optimizer='adam',loss='categorical_crossentropy',metrics=['accuracy'])\nhis=model.fit(datagen.flow(trainx,trainy,batch_size=32),validation_data=(testx,testy),epochs=30)\ny_pred=model.predict(testx)\npred=np.argmax(y_pred,axis=1)\nground = np.argmax(testy,axis=1)\nprint(classification_report(ground,pred))\nget_acc = his.history['accuracy']\nvalue_acc = his.history['val_accuracy']\nget_loss = his.history['loss']",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "ground",
        "kind": 5,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "ground = np.argmax(testy,axis=1)\nprint(classification_report(ground,pred))\nget_acc = his.history['accuracy']\nvalue_acc = his.history['val_accuracy']\nget_loss = his.history['loss']\nvalidation_loss = his.history['val_loss']\nepochs = range(len(get_acc))\nplt.plot(epochs, get_acc, 'r', label='Accuracy of Training data')\nplt.plot(epochs, value_acc, 'b', label='Accuracy of Validation data')\nplt.title('Training vs validation accuracy')",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "get_acc",
        "kind": 5,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "get_acc = his.history['accuracy']\nvalue_acc = his.history['val_accuracy']\nget_loss = his.history['loss']\nvalidation_loss = his.history['val_loss']\nepochs = range(len(get_acc))\nplt.plot(epochs, get_acc, 'r', label='Accuracy of Training data')\nplt.plot(epochs, value_acc, 'b', label='Accuracy of Validation data')\nplt.title('Training vs validation accuracy')\nplt.legend(loc=0)\nplt.figure()",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "value_acc",
        "kind": 5,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "value_acc = his.history['val_accuracy']\nget_loss = his.history['loss']\nvalidation_loss = his.history['val_loss']\nepochs = range(len(get_acc))\nplt.plot(epochs, get_acc, 'r', label='Accuracy of Training data')\nplt.plot(epochs, value_acc, 'b', label='Accuracy of Validation data')\nplt.title('Training vs validation accuracy')\nplt.legend(loc=0)\nplt.figure()\nplt.show()",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "get_loss",
        "kind": 5,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "get_loss = his.history['loss']\nvalidation_loss = his.history['val_loss']\nepochs = range(len(get_acc))\nplt.plot(epochs, get_acc, 'r', label='Accuracy of Training data')\nplt.plot(epochs, value_acc, 'b', label='Accuracy of Validation data')\nplt.title('Training vs validation accuracy')\nplt.legend(loc=0)\nplt.figure()\nplt.show()\nepochs = range(len(get_loss))",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "validation_loss",
        "kind": 5,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "validation_loss = his.history['val_loss']\nepochs = range(len(get_acc))\nplt.plot(epochs, get_acc, 'r', label='Accuracy of Training data')\nplt.plot(epochs, value_acc, 'b', label='Accuracy of Validation data')\nplt.title('Training vs validation accuracy')\nplt.legend(loc=0)\nplt.figure()\nplt.show()\nepochs = range(len(get_loss))\nplt.plot(epochs, get_loss, 'r', label='Loss of Training data')",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "epochs",
        "kind": 5,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "epochs = range(len(get_acc))\nplt.plot(epochs, get_acc, 'r', label='Accuracy of Training data')\nplt.plot(epochs, value_acc, 'b', label='Accuracy of Validation data')\nplt.title('Training vs validation accuracy')\nplt.legend(loc=0)\nplt.figure()\nplt.show()\nepochs = range(len(get_loss))\nplt.plot(epochs, get_loss, 'r', label='Loss of Training data')\nplt.plot(epochs, validation_loss, 'b', label='Loss of Validation data')",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "epochs",
        "kind": 5,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "epochs = range(len(get_loss))\nplt.plot(epochs, get_loss, 'r', label='Loss of Training data')\nplt.plot(epochs, validation_loss, 'b', label='Loss of Validation data')\nplt.title('Training vs validation loss')\nplt.legend(loc=0)\nplt.figure()\nplt.show()\nload_img(\"breeds/TEST/1006.jpg\",target_size=(180,180))\nimage=load_img(\"breeds/TEST/1006.jpg\",target_size=(180,180))\nimage=img_to_array(image) ",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "reverse_mapping",
        "kind": 5,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "reverse_mapping = { 'basset_hound':3, 'beagle':4, 'russian_blue':27, 'pomeranian':24, 'ragdoll':26, \n         'staffordshire_bull_terrier':34, 'keeshond':18, 'siamese':32, 'pug':25, 'shiba_inu':31, \n         'american_pit_bull_terrier':2, 'bengal':5, 'british_shorthair':9, 'newfoundland':22, \n         'havanese':16, 'japanese_chin':17, 'german_shorthaired':14, 'birman':6, 'maine_coon':20, \n         'english_cocker_spaniel':12, 'scottish_terrier':30, 'wheaten_terrier':35, 'chihuahua':10, \n         'american_bulldog':1, 'abyssinian':0, 'boxer':8, 'yorkshire_terrier':36, 'miniature_pinscher':21, \n         'sphynx':33, 'samoyed':29, 'leonberger':19, 'bombay':7, 'english_setter':13, 'persian':23, \n         'great_pyrenees':15, 'egyptian_mau':11, 'saint_bernard':28 }\ndef mapper(value):\n    return reverse_mapping[value]",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "mapper",
        "kind": 2,
        "importPath": "model",
        "description": "model",
        "peekOfCode": "def mapper(value):\n    return reverse_mapping[value]\n# PREDICTION\n#Use prediction to get best match stored in value var\nprint(prediction_image)\nprediction=model.predict(prediction_image)\nvalue=np.argmax(prediction)\nmove_name=mapper(value)\nprint(f\"Prediction is {format(move_name).capitalize()}.\")",
        "detail": "model",
        "documentation": {}
    },
    {
        "label": "model",
        "kind": 5,
        "importPath": "model",
        "description": "model",
        "peekOfCode": "model = keras.models.load_model('models/model1.h5')\n#Show user image to verify pet\nimage.show()\n#Parse image into array for machine learning purposes\nimage=img_to_array(image) \nimage=image/255.0\nprediction_image=np.array(image)\nprediction_image= np.expand_dims(image, axis=0)\n#Map number value back to breed name based on (reverse) mapping created in main.py\n# reverse_mapping={  0:'basset_hound', 1:'beagle', 2:'russian_blue', 3:'pomeranian', 4:'ragdoll', ",
        "detail": "model",
        "documentation": {}
    }
]